{"meta":{"title":"Su's Blog","subtitle":"写文档好麻烦啊","description":null,"author":"suyouxiong","url":"http://you-x.github.io"},"pages":[{"title":"","date":"2016-05-29T11:24:54.000Z","updated":"2016-05-29T11:24:54.000Z","comments":true,"path":"404.html","permalink":"http://you-x.github.io/404.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null}],"posts":[{"title":"聊一下c++中的函数指针","slug":"study-pointer-of-function","date":"2016-05-25T15:50:19.000Z","updated":"2016-05-29T04:08:34.000Z","comments":true,"path":"2016/05/25/study-pointer-of-function/","link":"","permalink":"http://you-x.github.io/2016/05/25/study-pointer-of-function/","excerpt":"最近在学习c++，想一边学习一边做笔记。使用博客来做笔记好像也挺大材小用的，没办法，也在培养写博客的习惯，就随便写一些吧。那么，就来说一下我在学习c++函数指针时的想法。 说起函数指针，隐约记得大一上c语言这门课有学，然而那时自己愚钝，就是理解不了（或许那时理解了，却忘了）。现在重新学起，感觉没那么吃力了，毕竟有学习了其它语言的积累。 那么，什么是函数指针？在我理解，就是指向函数的指针。有了这种指针，那么可以把函数进行传递。如果没有指针，一个函数就只能被调用。把函数进行传递，可以有什么作用？下面看一个例子。","keywords":null,"text":"最近在学习c++，想一边学习一边做笔记。使用博客来做笔记好像也挺大材小用的，没办法，也在培养写博客的习惯，就随便写一些吧。那么，就来说一下我在学习c++函数指针时的想法。 说起函数指针，隐约记得大一上c语言这门课有学，然而那时自己愚钝，就是理解不了（或许那时理解了，却忘了）。现在重新学起，感觉没那么吃力了，毕竟有学习了其它语言的积累。 那么，什么是函数指针？在我理解，就是指向函数的指针。有了这种指针，那么可以把函数进行传递。如果没有指针，一个函数就只能被调用。把函数进行传递，可以有什么作用？下面看一个例子。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;double add(double, double);double sub(double, double);double operation(double (*pf)(double, double), double, double);int main(int argc, char const *argv[]) &#123; /* code */ using namespace std; double a = 1.4; double b = 1.5; cout &lt;&lt; &quot;ensure the operator is:&quot;; char op = getchar(); double (*opf)(double, double);//声明一个函数指针变量，指向的函数结构是有两个double型参数，并且返回double类型的值 switch (op) &#123; case &apos;+&apos;: opf = add; break; case &apos;-&apos;: opf = sub; break; &#125; cout &lt;&lt; &quot;the result is :&quot; &lt;&lt; operation(opf, a, b) &lt;&lt; endl; return 0;&#125;double add(double a, double b) &#123; return a + b;&#125;double sub(double a, double b) &#123; return a - b;&#125;double operation(double (*pf)(double, double), double a, double b) &#123; return pf(a, b);&#125; 这段程序的目的是接收一个”+”或”-“号字符，然后决定对两个变量进行加法或减法运算，最后输出计算结果。 首先定义两个函数add和sub，分别用来进行加法和减法运算。然后通过输入的字符来判断，用一个函数指针类型变量opf指向对应的函数（也可以说是函数的地址赋给这个变量）。最后调用opf来进行运算。 现在可能看不出函数指针有什么优点。但假如运算的种类多了，有了乘除，或者其它符合double ...(double, double)结构的函数。如果不用函数指针，就必须在每个case语句中调用方法，无疑有了重复代码。所以有了函数指针，编程会变得灵活（肯定也还有其它高级的用法）。 相似的Javascript当我知道函数指针的基本使用时，脑海中马上浮现出Javascript中也有类似的使用场景。因为Javascript中函数是一种对象，可以赋值给任意变量。也就是说，Javascript中变量可以指向函数。先看看如何用Javascript实现上面c++的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;html&gt;&lt;head&gt; &lt;title&gt;begin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;ensure the operator is:&lt;/p&gt; &lt;input id=&quot;operator&quot; width=&quot;100px&quot; /&gt; &lt;button id=&quot;btn&quot; onclick=&quot;onClick()&quot;&gt;calc&lt;/button&gt; &lt;p id=&quot;result-output&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function add(a, b) &#123; return a + b; &#125; function sub(a, b) &#123; return a - b; &#125; function operation(func, a, b) &#123; return func(a, b); &#125; function onClick() &#123; var a = 1.4, b = 1.5; var input = document.getElementById(&apos;operator&apos;); var opf; switch (input.value) &#123; case &apos;+&apos;: opf = add; break; case &apos;-&apos;: opf = sub; break; default: &#125; document.getElementById(&apos;result-output&apos;).innerHTML = &apos;the result is :&apos; + operation(opf, a, b); &#125;&lt;/script&gt;&lt;/html 相似度是不是很高。唯一的区别就是在javascript中，变量是弱类型的，不用声明它是指向函数对象的变量。 所以通过类比，我更容易理解函数指针了。就是一个变量来引用函数，但是这个变量是具体函数的类型的。什么叫具体函数的类型？一个函数的结构是怎样的？看看函数原型的定义：返回值类型＋函数名＋参数类型。函数名是具体的，其它两部分是类型。也就是说，只有“返回值类型＋参数类型”才能把函数归纳起来成为类型。像上面的例子： double add(double, double);double sub(double, double); 函数add和sub的类型就是返回值为double类型，参数为两个double类型。后面就定义了这样一个类型的函数指针：double (*opf)(double, double)。看到这个声明，可以这样理解：opf变量的类型是函数指针，它只能指向返回值为double类型的，有两个double类型参数的函数。","raw":null,"content":null,"categories":[{"name":"study","slug":"study","permalink":"http://you-x.github.io/categories/study/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://you-x.github.io/tags/c/"},{"name":"函数指针","slug":"函数指针","permalink":"http://you-x.github.io/tags/函数指针/"}]},{"title":"Android Studio加入jni模块并调试jni代码","slug":"jni_in_android_studio","date":"2016-05-19T16:02:44.000Z","updated":"2016-05-25T13:16:53.000Z","comments":true,"path":"2016/05/20/jni_in_android_studio/","link":"","permalink":"http://you-x.github.io/2016/05/20/jni_in_android_studio/","excerpt":"最新Android Studio支持jni啦！ 但是google上搜索资料是说使用experimental版本插件（Experimental Plugin User Guide）来集成jni模块，我试过的确好用，会自动帮你生成对应的jni方法，不用使用javah生成头文件，再用ndk工具编译出so库再使用了。但是experimental版本插件现在还在测试中，而且进度缓慢，另外对build.gradle的配置也和普通的不一样，不知道是否有不稳定的情况。 然而，最近有个同事在研究一门技术时发现普通的android gradle插件也可以加入jni模块，和experimental版本插件差不多。瞬间觉得很高大上，但是google有没用相关的说明，觉得奇怪，莫非也是在测试阶段？管它呢，先知道一下怎么玩再说。","keywords":null,"text":"最新Android Studio支持jni啦！ 但是google上搜索资料是说使用experimental版本插件（Experimental Plugin User Guide）来集成jni模块，我试过的确好用，会自动帮你生成对应的jni方法，不用使用javah生成头文件，再用ndk工具编译出so库再使用了。但是experimental版本插件现在还在测试中，而且进度缓慢，另外对build.gradle的配置也和普通的不一样，不知道是否有不稳定的情况。 然而，最近有个同事在研究一门技术时发现普通的android gradle插件也可以加入jni模块，和experimental版本插件差不多。瞬间觉得很高大上，但是google有没用相关的说明，觉得奇怪，莫非也是在测试阶段？管它呢，先知道一下怎么玩再说。 运行环境 Android Studio 2.0 android build tool 插件版本：2.0.0(‘com.android.tools.build:gradle:2.0.0’) gradle 2.10 步骤 使用studio新建一个普通的android应用项目 检查local.properties文件中是否有指定ndk的路径，如无参考sdk路径配置ndk的路径，如： 12ndk.dir=/Users/suyouxiong/Library/Android/sdk/ndk-bundlesdk.dir=/Users/suyouxiong/Library/Android/sdk 在build.gradle中添加ndk模块 12345678910111213android &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.2&quot; defaultConfig &#123; ... ... ndk &#123; moduleName &quot;hello-ndk&quot; &#125; &#125;&#125; 此时sync会报错： Error:(14, 0) NDK integration is deprecated in the current plugin. Consider trying the new experimental pluginSet “android.useDeprecatedNdk=true” in gradle.properties to continue using the current NDK integration 从错误信息可以看到要么使用experimental版本插件（Experimental Plugin User Guide），要么是在gradle.properties添加android.useDeprecatedNdk=true配置。这里我们是要用平常的插件来集成jni，所以采用后面的解决方法。在项目根目录的gradle.properties文件添加android.useDeprecatedNdk=true，再次sync问题解决。 在src/main目录下创建jni目录用于存放本地代码，也可以选中app之后执行File &gt; New &gt; Folder &gt; JNI Folder创建 在MainActivity中加载jni模块并声明native方法： 12345static &#123; System.loadLibrary(&quot;hello-ndk&quot;);&#125;private native String getStringNative(); 此时studio会提示找不到该方法。使用快捷键alt+enter，这时会弹出解决方法列表，选择创建c方法，studio会自动创建一个和模块名相同的c文件，但并不会自动创建方法。 手动编写c方法，如果没有显式去配置java方法和c方法的对应关系，c方法名默认应该是Java+包路径（.用下划线_替换）+类名+加方法名，对应getStringNative方法，这样写： 12345JNIEXPORT jstring JNICALL Java_com_meizu_flyme_awesomendk_MainActivity_getStringNative(JNIEnv *env, jobject instance) &#123; // TODO return (*env)-&gt;NewStringUTF(env, &quot;Hello from JNI !&quot;);&#125; ps：如果你是copy上面这段代码，注意方法名要和你应用的实际情况相符 在MainActivity中使用getStringNative方法，直接使用一个TextView来显示即可： 12345678910@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... ... TextView tv = (TextView) findViewById(R.id.hello_ndk); tv.setText(getStringNative());&#125; 运行，ok jni代码调试有个同事突然和我说现在studio可以调试本地代码，我立马感到吃惊。虽然我不写jni模块，但是可以让大家知道怎么回事啊。 首先在build.gradle中打开jni调试： 1234567891011121314android &#123; ... ... buildTypes &#123; release &#123; ... ... &#125; debug &#123; jniDebuggable true &#125; &#125;&#125; 选择Run &gt; Edit Configurations，进入运行调试设置窗口，选择Debugger便签页，在debug type下拉选项中选择native，此时你可能会看到下面的error（如果没有那么可以退出设置，跳过后面步骤直接debug运行调试了）： studio给我们提供了快速解决方法，点击error信息后面的fix按钮，弹出相关包的安装信息，和安装sdk中的其它工具一样，选择Accept，点击下一步进行安装 安装完成后回到Run &gt; Edit Configurations窗口，发现error解决了，这时需要把debug type选回Java，因为app这个运行配置应该对应java代码的（这是我后面才明白过来，在Android Application下面还有个Android Native，这个才是配置native运行配置的，前面的操作无非是要安装那个c++调试包） 安装完之后点击OK按钮退出Run &gt; Edit Configurations窗口，回到主窗口，在运行配置选择下拉框就多出了native的配置项 选择app-native，在c代码打上断点，开始调试咯 进入Run &gt; Edit Configurations窗口看看app-native的配置，会发现其debug type默认是Hybrid，另外还有native选择，经过测试选择native也是可以调试的，但是只能调试c代码，不能调试java代码，而Hybrid是都可以的（好方便）。 以上 想想还是附上源码作为参考吧：https://github.com/you-x/AwesomNdk","raw":null,"content":null,"categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://you-x.github.io/tags/Android/"},{"name":"jni","slug":"jni","permalink":"http://you-x.github.io/tags/jni/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://you-x.github.io/tags/Android-Studio/"}]},{"title":"Android中窗口添加ActionBar","slug":"window-add-action-bar","date":"2016-05-18T16:02:44.000Z","updated":"2016-05-25T13:16:07.000Z","comments":true,"path":"2016/05/19/window-add-action-bar/","link":"","permalink":"http://you-x.github.io/2016/05/19/window-add-action-bar/","excerpt":"有没有想过，在eclipse或studio中创建一个android项目，自动生成app工程后直接运行就能看到ActionBar的存在，而且看工程代码里并没有添加ActionBar相关的代码，这是为什么呢？很显然，在默认的情况下，系统（或兼容库）提供的窗口已集成了ActionBar，应用开发只需要使用它即可。 在应用setContentView的时候，系统会为这个窗口添加一个基础的布局来作为应用内容的容器。在Activity中setContentView最终会调用到PhoneWindow中的setContentView方法（关于PhoneWindow的构造过程可以参考其它资料），PhoneWindow是管理窗口基础内容的类。看看它的setContentView方法：","keywords":null,"text":"有没有想过，在eclipse或studio中创建一个android项目，自动生成app工程后直接运行就能看到ActionBar的存在，而且看工程代码里并没有添加ActionBar相关的代码，这是为什么呢？很显然，在默认的情况下，系统（或兼容库）提供的窗口已集成了ActionBar，应用开发只需要使用它即可。 在应用setContentView的时候，系统会为这个窗口添加一个基础的布局来作为应用内容的容器。在Activity中setContentView最终会调用到PhoneWindow中的setContentView方法（关于PhoneWindow的构造过程可以参考其它资料），PhoneWindow是管理窗口基础内容的类。看看它的setContentView方法： 12345678910111213@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else &#123; mContentParent.removeAllViews(); &#125; mLayoutInflater.inflate(layoutResID, mContentParent); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125;&#125; 可以看到应用的content是添加到一个用变量mContentParent指向的布局类中，而installDecor方法就是初始化这个mContentParent的地方 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); .... &#125;&#125;protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. TypedArray a = getWindowStyle();....// 从主题中读取窗口属性，是否无标题和是否需要ActionBar，这两个属性会影响ActionBar的有无 if (a.getBoolean(com.android.internal.R.styleable.Window_windowNoTitle, false)) &#123; requestFeature(FEATURE_NO_TITLE); &#125; else if (a.getBoolean(com.android.internal.R.styleable.Window_windowActionBar, false)) &#123; // Don&apos;t allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); &#125; .... // Inflate the window decor. int layoutResource; int features = getLocalFeatures(); // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features)); if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; ... &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; ... &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; ... &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; // 如果主题中没有请求上面奇怪的属性，就会进入到这里。一般应用使用的设备主题（DeviceDefault）、Material主题和Holo主题，都会进入到这里 // If no other features and not embedded, only need a title. // If the window is floating, we need a dialog layout if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( com.android.internal.R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123;// 如果不是浮动窗口并且有ActionBar特效（上面requestFeature加入的） if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR_OVERLAY)) != 0) &#123; layoutResource = com.android.internal.R.layout.screen_action_bar_overlay; &#125; else &#123; // 一般也不会请求overlay模式的ActionBar layoutResource = com.android.internal.R.layout.screen_action_bar; &#125; &#125; else &#123; layoutResource = com.android.internal.R.layout.screen_title; &#125; // System.out.println(&quot;Title!&quot;); &#125; else &#123; ... &#125; mDecor.startChanging(); // 使用带有ActionBar的布局，把它加入整个窗口的root view——decorView中 View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); // 从当前view tree中找到id为content的view group作为应用content的容器 ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;); &#125; ... mDecor.finishChanging(); return contentParent;&#125; 上面看到在installDecor过程中，使用一个布局文件inflate进整个窗口的view tree中。这个布局文件就是前面说的窗口的基础布局。我们看看带有ActionBar的布局是怎样的，找到screen_action_bar.xml这个文件： 123456789101112131415161718192021222324252627282930313233343536373839&lt;com.android.internal.widget.ActionBarOverlayLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/decor_content_parent&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:splitMotionEvents=&quot;false&quot; android:theme=&quot;?attr/actionBarTheme&quot;&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;com.android.internal.widget.ActionBarContainer android:id=&quot;@+id/action_bar_container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentTop=&quot;true&quot; style=&quot;?attr/actionBarStyle&quot; android:transitionName=&quot;android:action_bar&quot; android:touchscreenBlocksFocus=&quot;true&quot; android:gravity=&quot;top&quot;&gt; &lt;com.android.internal.widget.ActionBarView android:id=&quot;@+id/action_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;?attr/actionBarStyle&quot; /&gt; &lt;com.android.internal.widget.ActionBarContextView android:id=&quot;@+id/action_context_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;gone&quot; style=&quot;?attr/actionModeStyle&quot; /&gt; &lt;/com.android.internal.widget.ActionBarContainer&gt; &lt;com.android.internal.widget.ActionBarContainer android:id=&quot;@+id/split_action_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;?attr/actionBarSplitStyle&quot; android:visibility=&quot;gone&quot; android:touchscreenBlocksFocus=&quot;true&quot; android:gravity=&quot;center&quot;/&gt;&lt;/com.android.internal.widget.ActionBarOverlayLayout&gt; 看到这个布局中的view你应该明白点什么了吧，那么多带“ActionBar”字样的view，明显就是一套为ActionBar服务的布局。于是也应该纠正认为ActionBar就是一个view的想法，有许多view为ActionBar的功能服务呢。 回到初始化基础布局的流程中，读取两个属性windowNoTitle和windowActionBar来决定是否取带有上述一套ActionBar的view的布局。所以使用Theme.Material.Light.NoActionBar主题来实现没有标题栏的原理就是那么简单： 12345&lt;!-- Variant of the material (light) theme with no action bar. --&gt;&lt;style name=&quot;Theme.Material.Light.NoActionBar&quot;&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 就是这样，PhoneWindow会根据主题的设置来决定是否要集成一套为ActionBar服务的view。但是现在只是加入了view而已，刚刚说了ActionBar不是一个view，而是一套方法，通过这些方法去控制这些view的行为来实现它的功能。那么ActionBar是怎样和这些view关联在一起的呢？我们看回Activity的getActionBar()方法: 1234567891011121314151617181920212223242526272829/** * Retrieve a reference to this activity&apos;s ActionBar. * * @return The Activity&apos;s ActionBar, or null if it does not have one. */@Nullablepublic ActionBar getActionBar() &#123; initWindowDecorActionBar(); return mActionBar;&#125;/** * Creates a new ActionBar, locates the inflated ActionBarView, * initializes the ActionBar with the view, and sets mActionBar. */private void initWindowDecorActionBar() &#123; Window window = getWindow(); // Initializing the window decor can change window feature flags. // Make sure that we have the correct set before performing the test below. window.getDecorView(); if (isChild() || !window.hasFeature(Window.FEATURE_ACTION_BAR) || mActionBar != null) &#123; return; &#125; mActionBar = new WindowDecorActionBar(this); mActionBar.setDefaultDisplayHomeAsUpEnabled(mEnableDefaultActionBarUp); mWindow.setDefaultIcon(mActivityInfo.getIconResource()); mWindow.setDefaultLogo(mActivityInfo.getLogoResource());&#125; 返回ActionBar的引用前进行一次初始化，然后看到真正返回的是WindowDecorActionBar的实例，这个类继承了ActionBar并实现了它的所有方法。在new这个WindowDecorActionBar的时候传人了当前Activity的引用。再看看WindowDecorActionBar的构造方法里做了什么操作 123456789101112131415161718192021222324252627282930313233343536public WindowDecorActionBar(Activity activity) &#123; mActivity = activity; Window window = activity.getWindow(); View decor = window.getDecorView(); boolean overlayMode = mActivity.getWindow().hasFeature(Window.FEATURE_ACTION_BAR_OVERLAY); init(decor); if (!overlayMode) &#123; mContentView = decor.findViewById(android.R.id.content); &#125;&#125;private void init(View decor) &#123; mOverlayLayout = (ActionBarOverlayLayout) decor.findViewById( com.android.internal.R.id.decor_content_parent); if (mOverlayLayout != null) &#123; mOverlayLayout.setActionBarVisibilityCallback(this); &#125; mDecorToolbar = getDecorToolbar(decor.findViewById(com.android.internal.R.id.action_bar)); mContextView = (ActionBarContextView) decor.findViewById( com.android.internal.R.id.action_context_bar); mContainerView = (ActionBarContainer) decor.findViewById( com.android.internal.R.id.action_bar_container); mSplitView = (ActionBarContainer) decor.findViewById( com.android.internal.R.id.split_action_bar); if (mDecorToolbar == null || mContextView == null || mContainerView == null) &#123; throw new IllegalStateException(getClass().getSimpleName() + &quot; can only be used &quot; + &quot;with a compatible window decor layout&quot;); &#125; mContext = mDecorToolbar.getContext(); mContextDisplayMode = mDecorToolbar.isSplit() ? CONTEXT_DISPLAY_SPLIT : CONTEXT_DISPLAY_NORMAL; ...&#125; 在构造方法里也是做一些初始化的工作，主要是从docor view（window的root view）中find到和ActionBar有关的view并保存到成员变量，那后续就可以控制这些view了。 至此，窗口就为应用集成了ActionBar","raw":null,"content":null,"categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://you-x.github.io/tags/Android/"},{"name":"ActionBar","slug":"ActionBar","permalink":"http://you-x.github.io/tags/ActionBar/"}]},{"title":"Android ActionBar计划","slug":"action-bar-plan","date":"2016-05-15T02:45:28.000Z","updated":"2016-05-25T02:10:06.000Z","comments":true,"path":"2016/05/15/action-bar-plan/","link":"","permalink":"http://you-x.github.io/2016/05/15/action-bar-plan/","excerpt":"开始写博客吧！ ActionBar学习计划前言对着ActionBar也有一段时间了，算是比较熟也能拿得出场子的东西，就以它作为开山之作吧。 想了解一下ActionBar的历史，猛的发现我们大神的博客有介绍ActionBar的使用，还十分详细，想了解用法的可以去看看：http://blog.csdn.net/xyz_lmn/article/details/8132420。 这里我就不废话ActionBar的前世今生了。虽然从Android 4.4开始，我就接触ActionBar，但我并不想再去详细说旧版本的东西，这是ActionBar的学习计划，我也本着学习的心态从较新的Android M版本出发来介绍ActionBar的实现。 由于ActionBar是一个比较庞大的组件，它并不是一个独立的View，是由许多View和控制辅助类来共同实现的，另外我是博客菜鸟，文章写的比较慢，如果要把一整套完成后才发布可能要等到猴年马月，所以打算是把它分成一系列的文章来学习，也算是一个循序渐进的过程，文章短短的也好接受（老罗的Android之旅尼玛有些文章长的我都没信心看了）。如果你看到这系列文章，我已经假定你已经把Android M的源码下载下来了。","keywords":null,"text":"开始写博客吧！ ActionBar学习计划前言对着ActionBar也有一段时间了，算是比较熟也能拿得出场子的东西，就以它作为开山之作吧。 想了解一下ActionBar的历史，猛的发现我们大神的博客有介绍ActionBar的使用，还十分详细，想了解用法的可以去看看：http://blog.csdn.net/xyz_lmn/article/details/8132420。 这里我就不废话ActionBar的前世今生了。虽然从Android 4.4开始，我就接触ActionBar，但我并不想再去详细说旧版本的东西，这是ActionBar的学习计划，我也本着学习的心态从较新的Android M版本出发来介绍ActionBar的实现。 由于ActionBar是一个比较庞大的组件，它并不是一个独立的View，是由许多View和控制辅助类来共同实现的，另外我是博客菜鸟，文章写的比较慢，如果要把一整套完成后才发布可能要等到猴年马月，所以打算是把它分成一系列的文章来学习，也算是一个循序渐进的过程，文章短短的也好接受（老罗的Android之旅尼玛有些文章长的我都没信心看了）。如果你看到这系列文章，我已经假定你已经把Android M的源码下载下来了。 计划大纲 ActionBar是Android UI的一个重要组成部分，是系统自动为应用窗口集成的。当应用使用了设备主题（DeviceDefault）、Material主题和Holo主题，系统就会加载用于实现ActionBar功能的View。然后应用通过ActionBar这个类提供的接口来控制显示或使用其功能。那么窗口集成的过程是怎样的，首先会对其进行剖析——Android中窗口添加ActionBar ActionBar是由众多View来共同实现的，那么每个View的作用和之间的关系是怎样的，会在第二篇文章来学习。 Toolbar，作为ActionBar最重要的功能实现View，以及Google非常推荐应用开发者放弃使用系统ActionBar而把Toolbar作为自己布局的一部分，然后调用setActionBar（或appcompat中的setSupportActionBar）方法来实现ActionBar的某些功能，它到底神奇在哪，第三篇文章来详细学习Toolbar的实现。 使用ActionBar，应该必不可少有option menu，ActionBar上的菜单也涉及非常多类。第四篇文章就来学习ActionBar如何加载和现实菜单。 option menu点击之后是如何回调到Activity中的onOptionMenuSelected方法的，第五篇文章来梳理菜单的点击响应流程。 这五篇文章完成后，对ActionBar应该都会有个感性并理性的认识，从此就不再觉得ActionBar有多神秘和厉害（当你对一样东西熟悉了就会觉得不过如是）。","raw":null,"content":null,"categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://you-x.github.io/tags/Android/"},{"name":"ActionBar","slug":"ActionBar","permalink":"http://you-x.github.io/tags/ActionBar/"}]},{"title":"首篇","slug":"hello-world","date":"2016-04-24T07:36:52.000Z","updated":"2016-05-25T12:02:29.000Z","comments":true,"path":"2016/04/24/hello-world/","link":"","permalink":"http://you-x.github.io/2016/04/24/hello-world/","excerpt":"","keywords":null,"text":"博客终于，参考大神的这篇文章《史上最详细的Hexo博客搭建图文教程》搭建了自己的博客，现在都是hexo提供的模版，感觉hexo屌屌的，以后会抽时间在样式的定制上。 写博客主要是为了总结自己，以及培养自己写文档的能力（不写文档的程序员都不是好程序员），希望能多产出。 目标由于现在的工作重点是android控件，所以先把自己以前做过的工作——frameworks的部分控件整理一些文档出来，算是总结吧。 希望有了博客的推动，自己会在技术上多上心，然后可以多分享一些技术。","raw":null,"content":null,"categories":[],"tags":[{"name":"none","slug":"none","permalink":"http://you-x.github.io/tags/none/"}]}]}