{"meta":{"title":"Su's Blog","subtitle":"写文档好麻烦啊","description":null,"author":"suyouxiong","url":"https://susyx.github.io"},"pages":[{"title":"","date":"2016-05-29T11:24:54.000Z","updated":"2016-05-29T11:24:54.000Z","comments":true,"path":"404.html","permalink":"https://susyx.github.io/404.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null}],"posts":[{"title":"ActionBar Option Menu创建流程","slug":"action-bar-menu","date":"2016-07-28T15:41:55.000Z","updated":"2019-09-10T12:22:55.000Z","comments":true,"path":"2016/07/28/action-bar-menu/","link":"","permalink":"https://susyx.github.io/2016/07/28/action-bar-menu/","excerpt":"Option MenuOption Menu，从翻译来看是“选择菜单”的意思，然而某些专业名词就不应该给它翻译，大家简单认为它是在ActionBar上面的一种菜单即可。在Android中，菜单还有其它几种，例如上下文菜单——Context Menu，弹出菜单——PopupMenu。其中Option Menu和Context Menu都是通过Activity中的回调方法来创建的。 相信大家也很清楚Option Menu如何使用。在Activity里的回调方法onCreateOptionsMenu方法中添加菜单项到Menu中，并返回true即可： 12345@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_main, menu); return true;&#125; 然后在方法onOptionsItemSelected对菜单项的点击事件进行监听： 1234567891011@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.action1 : return true; case android.R.id.home : onBackPressed(); return true; &#125; return super.onOptionsItemSelected(item);&#125; Option Menu创建流程","keywords":null,"text":"Option MenuOption Menu，从翻译来看是“选择菜单”的意思，然而某些专业名词就不应该给它翻译，大家简单认为它是在ActionBar上面的一种菜单即可。在Android中，菜单还有其它几种，例如上下文菜单——Context Menu，弹出菜单——PopupMenu。其中Option Menu和Context Menu都是通过Activity中的回调方法来创建的。 相信大家也很清楚Option Menu如何使用。在Activity里的回调方法onCreateOptionsMenu方法中添加菜单项到Menu中，并返回true即可： 12345@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_main, menu); return true;&#125; 然后在方法onOptionsItemSelected对菜单项的点击事件进行监听： 1234567891011@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.action1 : return true; case android.R.id.home : onBackPressed(); return true; &#125; return super.onOptionsItemSelected(item);&#125; Option Menu创建流程 使用hierarchyviewer工具观察带有Option Menu的窗口，可以知道这些菜单的按钮是在Action Bar上面的。 入口我前面的文章 《Android中窗口添加ActionBar》 中，PhoneWindow创建一套ActionBar的layout添加到当前窗口中。就是在installDecor方法中，创建了布局后，post一个任务（menu创建也算比较复杂，post应该是为了不要拖慢启动速度） 123456789101112131415161718192021222324252627282930313233343536private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor(); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); if (decorContentParent != null) &#123; .... // Invalidate if the panel menu hasn't been created before this. // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu // being called in the middle of onCreate or similar. // A pending invalidation will typically be resolved before the posted message // would run normally in order to satisfy instance state restoration. PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false); if (!isDestroyed() &amp;&amp; (st == null || st.menu == null) &amp;&amp; !mIsStartingWindow) &#123; //触发刷新菜单 invalidatePanelMenu(FEATURE_ACTION_BAR); &#125; &#125; else &#123; ... &#125; &#125;&#125;@Overridepublic void invalidatePanelMenu(int featureId) &#123; mInvalidatePanelMenuFeatures |= 1 &lt;&lt; featureId; if (!mInvalidatePanelMenuPosted &amp;&amp; mDecor != null) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); mInvalidatePanelMenuPosted = true; &#125;&#125; 开始创建上面post一个任务来进行菜单的创建，从Runnable的实现知道是从PhoneWindow的doInvalidatePanelMenu方法开始，随即会进入preparePanel开始菜单的详细创建流程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public final boolean preparePanel(PanelFeatureState st, KeyEvent event) &#123; ... //对应Activity的窗口，这个Callback就是Activity。Activity实现了这个接口，并在attach方法中对Window设置了这个Callback final Callback cb = getCallback(); //这个回调是提供给应用自定义菜单面板的，一般不会重写这个方法 if (cb != null) &#123; st.createdPanelView = cb.onCreatePanelView(st.featureId); &#125; final boolean isActionBarMenu = (st.featureId == FEATURE_OPTIONS_PANEL || st.featureId == FEATURE_ACTION_BAR); ... //下面这段就是设置option menu的。可以看到，如果上面的onCreatePanelView if (st.createdPanelView == null) &#123; // Init the panel state's menu--return false if init failed if (st.menu == null || st.refreshMenuContent) &#123; if (st.menu == null) &#123; if (!initializePanelMenu(st) || (st.menu == null)) &#123; return false; &#125; &#125; if (isActionBarMenu &amp;&amp; mDecorContentParent != null) &#123; if (mActionMenuPresenterCallback == null) &#123; mActionMenuPresenterCallback = new ActionMenuPresenterCallback(); &#125; mDecorContentParent.setMenu(st.menu, mActionMenuPresenterCallback); &#125; // Call callback, and return if it doesn't want to display menu. // Creating the panel menu will involve a lot of manipulation; // don't dispatch change events to presenters until we're done. st.menu.stopDispatchingItemsChanged(); if ((cb == null) || !cb.onCreatePanelMenu(st.featureId, st.menu)) &#123; // Ditch the menu created above st.setMenu(null); if (isActionBarMenu &amp;&amp; mDecorContentParent != null) &#123; // Don't show it in the action bar either mDecorContentParent.setMenu(null, mActionMenuPresenterCallback); &#125; return false; &#125; st.refreshMenuContent = false; &#125; ... if (!cb.onPreparePanel(st.featureId, st.createdPanelView, st.menu)) &#123; if (isActionBarMenu &amp;&amp; mDecorContentParent != null) &#123; // The app didn't want to show the menu for now but it still exists. // Clear it out of the action bar. mDecorContentParent.setMenu(null, mActionMenuPresenterCallback); &#125; st.menu.startDispatchingItemsChanged(); return false; &#125; ... st.menu.startDispatchingItemsChanged(); &#125; ... return true;&#125; 未完待续","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://susyx.github.io/categories/Android/"}],"tags":[{"name":"ActionBar","slug":"ActionBar","permalink":"https://susyx.github.io/tags/ActionBar/"},{"name":"Option Menu","slug":"Option-Menu","permalink":"https://susyx.github.io/tags/Option-Menu/"}]},{"title":"github博客关联域名","slug":"github-page-domain","date":"2016-06-25T11:11:39.000Z","updated":"2016-07-19T15:40:42.000Z","comments":true,"path":"2016/06/25/github-page-domain/","link":"","permalink":"https://susyx.github.io/2016/06/25/github-page-domain/","excerpt":"github博客github是程序员最喜欢的交友网站，github博客（github pages）是程序员越来越喜欢的个人主页。 上面这句话不是我说的，然而作为一个程序员，我应该也要站下队。于是我也在捣腾起github，有了这个博客。 怎么创建github pages并使用hexo开始写博之旅？自己网上找手把手教程，很多大牛都会手把手教你。 这里我来说说（记录）怎么给github pages绑定域名。关于绑定域名，网上也有很多相关的文章。 理论类的： 从DNS到github pages自定义域名 – 漫谈域名那些事 实操类的：Hexo在github上构建免费的Web应用 但可能这些都因为内容比较多，让你的脑袋转不过来。那我直接来死板教程，把我这个小白绑定域名的过程写一下。 前提：已经有可以访问的github pages","keywords":null,"text":"github博客github是程序员最喜欢的交友网站，github博客（github pages）是程序员越来越喜欢的个人主页。 上面这句话不是我说的，然而作为一个程序员，我应该也要站下队。于是我也在捣腾起github，有了这个博客。 怎么创建github pages并使用hexo开始写博之旅？自己网上找手把手教程，很多大牛都会手把手教你。 这里我来说说（记录）怎么给github pages绑定域名。关于绑定域名，网上也有很多相关的文章。 理论类的： 从DNS到github pages自定义域名 – 漫谈域名那些事 实操类的：Hexo在github上构建免费的Web应用 但可能这些都因为内容比较多，让你的脑袋转不过来。那我直接来死板教程，把我这个小白绑定域名的过程写一下。 前提：已经有可以访问的github pages 购买域名购买域名，其实就是购买域名的配置权。域名服务商，网上比较推荐的是”狗爹”—— godaddy。 就像注册用户名一样，大概想好自己想要的域名，然后搜索看是否已被购买。如下: 搜索到没有被take的域名后，就可以加入购物车了。后面就和普通商品一样下单支付了（现在狗爹支持支付宝付款，非常方便），还不用写收货地址，非常快捷。 现在，我就以我这个域名—— susyx.com 为例说明怎样配置。 修改域名解析服务默认情况下，域名会由它的服务商提供域名解析服务。例如，狗爹的域名默认是狗爹的域名解析服务来解析。不过可以在狗爹的域名配置后台设置域名的解析服务器。 网上很多文章说狗爹的域名解析有时候会被墙，推荐使用国内的 dnspod 来解析域名。 登陆狗爹，首页点击右上角的的用户头像按钮，可以看到下图中的菜单，选择Manage My Domains 进入“管理我的域名”页面，可以看到购买的所有域名，在你要修改的域名卡片右上角点击齿轮按钮，出现几个设置菜单，选择Manage DNS: 进入DNS Management页面，会看到由记录（Records）和域名解析服务（Nameservers）两项配置。在Nameservers配置卡片里，点击Change，选择Custom，填入dnspod的两个域名解析服务器地址： f1g1ns1.dnspod.netf1g1ns2.dnspod.net 保存即可 设置域名开始说正题。github pages支持关联域名，而我们也知道，github pages有两种： repository名和用户名一样，默认这个repository就是一个github pages，可以用username.github.io的域名直接访问，这种类型的github pages称为User or organization site; 随便一个repository，进入这个repository的settings，使用github pages的Automatic page generator功能用这个repository生成一个github pages，可以用username.github.io/repository_name来访问。这种类型的github pages称为Project site; 现在就来进行两种配置方式： 上面第一种的github pages映射到主域名：susyx.com 第二种github pages映射到子域名：yyq.susyx.com 设置主域名设置主域名相当简单，没玩这个前一度以为很麻烦，只需两步就搞定： 登陆dnspod并进入控制台-&gt;域名解析，选择需要解析的域名。添加下图的记录： 上图所示的记录直接解析主域名susyx.com，指向github pages的一个ip——192.30.252.153。github pages有两个ip： 192.30.252.153192.30.252.154 在github的帮助页面有关于如何设置自定义域名的文章，里面有提供其服务器ip，未来如果无法访问可以前往查看是否github更换了ip： Setting up an apex domain 在上述第一种类型的github pages项目的根目录新建一个CNAME文件（注意文件名就是CNAME，并且没有扩展名），里面写入要跳转的域名： susyx.com 如无意外，此时地址栏键入susyx.com就可以访问对应的github pages了，是不是很简单。 在我这个小白理解，主域名跳转是这样一个流程：访问域名susyx.com，实际是请求了github pages的主服务器：192.30.252.153，该服务器再根据我们配置的CNAME文件返回了****.github.io的内容。 设置子域名 对域名添加一条CNAME记录，如下： 记录值为：username.github.io 在上述第二种类型的github pages项目的根目录新建一个CNAME文件，里面写入要跳转的域名： yyq.susyx.com 如无意外，也是可以使用yyq.susyx.com代替username.github.io/repository_name的方式来访问Project site了","raw":null,"content":null,"categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"https://susyx.github.io/tags/blog/"},{"name":"域名","slug":"域名","permalink":"https://susyx.github.io/tags/域名/"},{"name":"github pages","slug":"github-pages","permalink":"https://susyx.github.io/tags/github-pages/"}]},{"title":"聊一下c++中的函数指针","slug":"study-pointer-of-function","date":"2016-05-25T15:50:19.000Z","updated":"2016-05-29T04:08:34.000Z","comments":true,"path":"2016/05/25/study-pointer-of-function/","link":"","permalink":"https://susyx.github.io/2016/05/25/study-pointer-of-function/","excerpt":"最近在学习c++，想一边学习一边做笔记。使用博客来做笔记好像也挺大材小用的，没办法，也在培养写博客的习惯，就随便写一些吧。那么，就来说一下我在学习c++函数指针时的想法。 说起函数指针，隐约记得大一上c语言这门课有学，然而那时自己愚钝，就是理解不了（或许那时理解了，却忘了）。现在重新学起，感觉没那么吃力了，毕竟有学习了其它语言的积累。 那么，什么是函数指针？在我理解，就是指向函数的指针。有了这种指针，那么可以把函数进行传递。如果没有指针，一个函数就只能被调用。把函数进行传递，可以有什么作用？下面看一个例子。","keywords":null,"text":"最近在学习c++，想一边学习一边做笔记。使用博客来做笔记好像也挺大材小用的，没办法，也在培养写博客的习惯，就随便写一些吧。那么，就来说一下我在学习c++函数指针时的想法。 说起函数指针，隐约记得大一上c语言这门课有学，然而那时自己愚钝，就是理解不了（或许那时理解了，却忘了）。现在重新学起，感觉没那么吃力了，毕竟有学习了其它语言的积累。 那么，什么是函数指针？在我理解，就是指向函数的指针。有了这种指针，那么可以把函数进行传递。如果没有指针，一个函数就只能被调用。把函数进行传递，可以有什么作用？下面看一个例子。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;double add(double, double);double sub(double, double);double operation(double (*pf)(double, double), double, double);int main(int argc, char const *argv[]) &#123; /* code */ using namespace std; double a = 1.4; double b = 1.5; cout &lt;&lt; &quot;ensure the operator is:&quot;; char op = getchar(); double (*opf)(double, double);//声明一个函数指针变量，指向的函数结构是有两个double型参数，并且返回double类型的值 switch (op) &#123; case &apos;+&apos;: opf = add; break; case &apos;-&apos;: opf = sub; break; &#125; cout &lt;&lt; &quot;the result is :&quot; &lt;&lt; operation(opf, a, b) &lt;&lt; endl; return 0;&#125;double add(double a, double b) &#123; return a + b;&#125;double sub(double a, double b) &#123; return a - b;&#125;double operation(double (*pf)(double, double), double a, double b) &#123; return pf(a, b);&#125; 这段程序的目的是接收一个”+”或”-“号字符，然后决定对两个变量进行加法或减法运算，最后输出计算结果。 首先定义两个函数add和sub，分别用来进行加法和减法运算。然后通过输入的字符来判断，用一个函数指针类型变量opf指向对应的函数（也可以说是函数的地址赋给这个变量）。最后调用opf来进行运算。 现在可能看不出函数指针有什么优点。但假如运算的种类多了，有了乘除，或者其它符合double ...(double, double)结构的函数。如果不用函数指针，就必须在每个case语句中调用方法，无疑有了重复代码。所以有了函数指针，编程会变得灵活（肯定也还有其它高级的用法）。 相似的Javascript当我知道函数指针的基本使用时，脑海中马上浮现出Javascript中也有类似的使用场景。因为Javascript中函数是一种对象，可以赋值给任意变量。也就是说，Javascript中变量可以指向函数。先看看如何用Javascript实现上面c++的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;html&gt;&lt;head&gt; &lt;title&gt;begin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;ensure the operator is:&lt;/p&gt; &lt;input id=&quot;operator&quot; width=&quot;100px&quot; /&gt; &lt;button id=&quot;btn&quot; onclick=&quot;onClick()&quot;&gt;calc&lt;/button&gt; &lt;p id=&quot;result-output&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function add(a, b) &#123; return a + b; &#125; function sub(a, b) &#123; return a - b; &#125; function operation(func, a, b) &#123; return func(a, b); &#125; function onClick() &#123; var a = 1.4, b = 1.5; var input = document.getElementById(&apos;operator&apos;); var opf; switch (input.value) &#123; case &apos;+&apos;: opf = add; break; case &apos;-&apos;: opf = sub; break; default: &#125; document.getElementById(&apos;result-output&apos;).innerHTML = &apos;the result is :&apos; + operation(opf, a, b); &#125;&lt;/script&gt;&lt;/html 相似度是不是很高。唯一的区别就是在javascript中，变量是弱类型的，不用声明它是指向函数对象的变量。 所以通过类比，我更容易理解函数指针了。就是一个变量来引用函数，但是这个变量是具体函数的类型的。什么叫具体函数的类型？一个函数的结构是怎样的？看看函数原型的定义：返回值类型＋函数名＋参数类型。函数名是具体的，其它两部分是类型。也就是说，只有“返回值类型＋参数类型”才能把函数归纳起来成为类型。像上面的例子： double add(double, double);double sub(double, double); 函数add和sub的类型就是返回值为double类型，参数为两个double类型。后面就定义了这样一个类型的函数指针：double (*opf)(double, double)。看到这个声明，可以这样理解：opf变量的类型是函数指针，它只能指向返回值为double类型的，有两个double类型参数的函数。","raw":null,"content":null,"categories":[{"name":"study","slug":"study","permalink":"https://susyx.github.io/categories/study/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://susyx.github.io/tags/c/"},{"name":"函数指针","slug":"函数指针","permalink":"https://susyx.github.io/tags/函数指针/"}]},{"title":"Android Studio加入jni模块并调试jni代码","slug":"jni_in_android_studio","date":"2016-05-19T16:02:44.000Z","updated":"2016-05-25T13:16:53.000Z","comments":true,"path":"2016/05/20/jni_in_android_studio/","link":"","permalink":"https://susyx.github.io/2016/05/20/jni_in_android_studio/","excerpt":"最新Android Studio支持jni啦！ 但是google上搜索资料是说使用experimental版本插件（Experimental Plugin User Guide）来集成jni模块，我试过的确好用，会自动帮你生成对应的jni方法，不用使用javah生成头文件，再用ndk工具编译出so库再使用了。但是experimental版本插件现在还在测试中，而且进度缓慢，另外对build.gradle的配置也和普通的不一样，不知道是否有不稳定的情况。 然而，最近有个同事在研究一门技术时发现普通的android gradle插件也可以加入jni模块，和experimental版本插件差不多。瞬间觉得很高大上，但是google有没用相关的说明，觉得奇怪，莫非也是在测试阶段？管它呢，先知道一下怎么玩再说。","keywords":null,"text":"最新Android Studio支持jni啦！ 但是google上搜索资料是说使用experimental版本插件（Experimental Plugin User Guide）来集成jni模块，我试过的确好用，会自动帮你生成对应的jni方法，不用使用javah生成头文件，再用ndk工具编译出so库再使用了。但是experimental版本插件现在还在测试中，而且进度缓慢，另外对build.gradle的配置也和普通的不一样，不知道是否有不稳定的情况。 然而，最近有个同事在研究一门技术时发现普通的android gradle插件也可以加入jni模块，和experimental版本插件差不多。瞬间觉得很高大上，但是google有没用相关的说明，觉得奇怪，莫非也是在测试阶段？管它呢，先知道一下怎么玩再说。 运行环境 Android Studio 2.0 android build tool 插件版本：2.0.0(‘com.android.tools.build:gradle:2.0.0’) gradle 2.10 步骤 使用studio新建一个普通的android应用项目 检查local.properties文件中是否有指定ndk的路径，如无参考sdk路径配置ndk的路径，如： 12ndk.dir=/Users/suyouxiong/Library/Android/sdk/ndk-bundlesdk.dir=/Users/suyouxiong/Library/Android/sdk 在build.gradle中添加ndk模块 12345678910111213android &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.2&quot; defaultConfig &#123; ... ... ndk &#123; moduleName &quot;hello-ndk&quot; &#125; &#125;&#125; 此时sync会报错： Error:(14, 0) NDK integration is deprecated in the current plugin. Consider trying the new experimental pluginSet “android.useDeprecatedNdk=true” in gradle.properties to continue using the current NDK integration 从错误信息可以看到要么使用experimental版本插件（Experimental Plugin User Guide），要么是在gradle.properties添加android.useDeprecatedNdk=true配置。这里我们是要用平常的插件来集成jni，所以采用后面的解决方法。在项目根目录的gradle.properties文件添加android.useDeprecatedNdk=true，再次sync问题解决。 在src/main目录下创建jni目录用于存放本地代码，也可以选中app之后执行File &gt; New &gt; Folder &gt; JNI Folder创建 在MainActivity中加载jni模块并声明native方法： 12345static &#123; System.loadLibrary(&quot;hello-ndk&quot;);&#125;private native String getStringNative(); 此时studio会提示找不到该方法。使用快捷键alt+enter，这时会弹出解决方法列表，选择创建c方法，studio会自动创建一个和模块名相同的c文件，但并不会自动创建方法。 手动编写c方法，如果没有显式去配置java方法和c方法的对应关系，c方法名默认应该是Java+包路径（.用下划线_替换）+类名+加方法名，对应getStringNative方法，这样写： 12345JNIEXPORT jstring JNICALL Java_com_meizu_flyme_awesomendk_MainActivity_getStringNative(JNIEnv *env, jobject instance) &#123; // TODO return (*env)-&gt;NewStringUTF(env, &quot;Hello from JNI !&quot;);&#125; ps：如果你是copy上面这段代码，注意方法名要和你应用的实际情况相符 在MainActivity中使用getStringNative方法，直接使用一个TextView来显示即可： 12345678910@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... ... TextView tv = (TextView) findViewById(R.id.hello_ndk); tv.setText(getStringNative());&#125; 运行，ok jni代码调试有个同事突然和我说现在studio可以调试本地代码，我立马感到吃惊。虽然我不写jni模块，但是可以让大家知道怎么回事啊。 首先在build.gradle中打开jni调试： 1234567891011121314android &#123; ... ... buildTypes &#123; release &#123; ... ... &#125; debug &#123; jniDebuggable true &#125; &#125;&#125; 选择Run &gt; Edit Configurations，进入运行调试设置窗口，选择Debugger便签页，在debug type下拉选项中选择native，此时你可能会看到下面的error（如果没有那么可以退出设置，跳过后面步骤直接debug运行调试了）： studio给我们提供了快速解决方法，点击error信息后面的fix按钮，弹出相关包的安装信息，和安装sdk中的其它工具一样，选择Accept，点击下一步进行安装 安装完成后回到Run &gt; Edit Configurations窗口，发现error解决了，这时需要把debug type选回Java，因为app这个运行配置应该对应java代码的（这是我后面才明白过来，在Android Application下面还有个Android Native，这个才是配置native运行配置的，前面的操作无非是要安装那个c++调试包） 安装完之后点击OK按钮退出Run &gt; Edit Configurations窗口，回到主窗口，在运行配置选择下拉框就多出了native的配置项 选择app-native，在c代码打上断点，开始调试咯 进入Run &gt; Edit Configurations窗口看看app-native的配置，会发现其debug type默认是Hybrid，另外还有native选择，经过测试选择native也是可以调试的，但是只能调试c代码，不能调试java代码，而Hybrid是都可以的（好方便）。 以上 想想还是附上源码作为参考吧：https://github.com/you-x/AwesomNdk","raw":null,"content":null,"categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://susyx.github.io/tags/Android/"},{"name":"jni","slug":"jni","permalink":"https://susyx.github.io/tags/jni/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://susyx.github.io/tags/Android-Studio/"}]},{"title":"Android中窗口添加ActionBar","slug":"window-add-action-bar","date":"2016-05-18T16:02:44.000Z","updated":"2016-05-25T13:16:07.000Z","comments":true,"path":"2016/05/19/window-add-action-bar/","link":"","permalink":"https://susyx.github.io/2016/05/19/window-add-action-bar/","excerpt":"有没有想过，在eclipse或studio中创建一个android项目，自动生成app工程后直接运行就能看到ActionBar的存在，而且看工程代码里并没有添加ActionBar相关的代码，这是为什么呢？很显然，在默认的情况下，系统（或兼容库）提供的窗口已集成了ActionBar，应用开发只需要使用它即可。 在应用setContentView的时候，系统会为这个窗口添加一个基础的布局来作为应用内容的容器。在Activity中setContentView最终会调用到PhoneWindow中的setContentView方法（关于PhoneWindow的构造过程可以参考其它资料），PhoneWindow是管理窗口基础内容的类。看看它的setContentView方法：","keywords":null,"text":"有没有想过，在eclipse或studio中创建一个android项目，自动生成app工程后直接运行就能看到ActionBar的存在，而且看工程代码里并没有添加ActionBar相关的代码，这是为什么呢？很显然，在默认的情况下，系统（或兼容库）提供的窗口已集成了ActionBar，应用开发只需要使用它即可。 在应用setContentView的时候，系统会为这个窗口添加一个基础的布局来作为应用内容的容器。在Activity中setContentView最终会调用到PhoneWindow中的setContentView方法（关于PhoneWindow的构造过程可以参考其它资料），PhoneWindow是管理窗口基础内容的类。看看它的setContentView方法： 12345678910111213@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else &#123; mContentParent.removeAllViews(); &#125; mLayoutInflater.inflate(layoutResID, mContentParent); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125;&#125; 可以看到应用的content是添加到一个用变量mContentParent指向的布局类中，而installDecor方法就是初始化这个mContentParent的地方 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); .... &#125;&#125;protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. TypedArray a = getWindowStyle();....// 从主题中读取窗口属性，是否无标题和是否需要ActionBar，这两个属性会影响ActionBar的有无 if (a.getBoolean(com.android.internal.R.styleable.Window_windowNoTitle, false)) &#123; requestFeature(FEATURE_NO_TITLE); &#125; else if (a.getBoolean(com.android.internal.R.styleable.Window_windowActionBar, false)) &#123; // Don&apos;t allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); &#125; .... // Inflate the window decor. int layoutResource; int features = getLocalFeatures(); // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features)); if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; ... &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; ... &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; ... &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; // 如果主题中没有请求上面奇怪的属性，就会进入到这里。一般应用使用的设备主题（DeviceDefault）、Material主题和Holo主题，都会进入到这里 // If no other features and not embedded, only need a title. // If the window is floating, we need a dialog layout if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( com.android.internal.R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123;// 如果不是浮动窗口并且有ActionBar特效（上面requestFeature加入的） if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR_OVERLAY)) != 0) &#123; layoutResource = com.android.internal.R.layout.screen_action_bar_overlay; &#125; else &#123; // 一般也不会请求overlay模式的ActionBar layoutResource = com.android.internal.R.layout.screen_action_bar; &#125; &#125; else &#123; layoutResource = com.android.internal.R.layout.screen_title; &#125; // System.out.println(&quot;Title!&quot;); &#125; else &#123; ... &#125; mDecor.startChanging(); // 使用带有ActionBar的布局，把它加入整个窗口的root view——decorView中 View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); // 从当前view tree中找到id为content的view group作为应用content的容器 ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;); &#125; ... mDecor.finishChanging(); return contentParent;&#125; 上面看到在installDecor过程中，使用一个布局文件inflate进整个窗口的view tree中。这个布局文件就是前面说的窗口的基础布局。我们看看带有ActionBar的布局是怎样的，找到screen_action_bar.xml这个文件： 123456789101112131415161718192021222324252627282930313233343536373839&lt;com.android.internal.widget.ActionBarOverlayLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/decor_content_parent&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:splitMotionEvents=&quot;false&quot; android:theme=&quot;?attr/actionBarTheme&quot;&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;com.android.internal.widget.ActionBarContainer android:id=&quot;@+id/action_bar_container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentTop=&quot;true&quot; style=&quot;?attr/actionBarStyle&quot; android:transitionName=&quot;android:action_bar&quot; android:touchscreenBlocksFocus=&quot;true&quot; android:gravity=&quot;top&quot;&gt; &lt;com.android.internal.widget.ActionBarView android:id=&quot;@+id/action_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;?attr/actionBarStyle&quot; /&gt; &lt;com.android.internal.widget.ActionBarContextView android:id=&quot;@+id/action_context_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;gone&quot; style=&quot;?attr/actionModeStyle&quot; /&gt; &lt;/com.android.internal.widget.ActionBarContainer&gt; &lt;com.android.internal.widget.ActionBarContainer android:id=&quot;@+id/split_action_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;?attr/actionBarSplitStyle&quot; android:visibility=&quot;gone&quot; android:touchscreenBlocksFocus=&quot;true&quot; android:gravity=&quot;center&quot;/&gt;&lt;/com.android.internal.widget.ActionBarOverlayLayout&gt; 看到这个布局中的view你应该明白点什么了吧，那么多带“ActionBar”字样的view，明显就是一套为ActionBar服务的布局。于是也应该纠正认为ActionBar就是一个view的想法，有许多view为ActionBar的功能服务呢。 回到初始化基础布局的流程中，读取两个属性windowNoTitle和windowActionBar来决定是否取带有上述一套ActionBar的view的布局。所以使用Theme.Material.Light.NoActionBar主题来实现没有标题栏的原理就是那么简单： 12345&lt;!-- Variant of the material (light) theme with no action bar. --&gt;&lt;style name=&quot;Theme.Material.Light.NoActionBar&quot;&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 就是这样，PhoneWindow会根据主题的设置来决定是否要集成一套为ActionBar服务的view。但是现在只是加入了view而已，刚刚说了ActionBar不是一个view，而是一套方法，通过这些方法去控制这些view的行为来实现它的功能。那么ActionBar是怎样和这些view关联在一起的呢？我们看回Activity的getActionBar()方法: 1234567891011121314151617181920212223242526272829/** * Retrieve a reference to this activity&apos;s ActionBar. * * @return The Activity&apos;s ActionBar, or null if it does not have one. */@Nullablepublic ActionBar getActionBar() &#123; initWindowDecorActionBar(); return mActionBar;&#125;/** * Creates a new ActionBar, locates the inflated ActionBarView, * initializes the ActionBar with the view, and sets mActionBar. */private void initWindowDecorActionBar() &#123; Window window = getWindow(); // Initializing the window decor can change window feature flags. // Make sure that we have the correct set before performing the test below. window.getDecorView(); if (isChild() || !window.hasFeature(Window.FEATURE_ACTION_BAR) || mActionBar != null) &#123; return; &#125; mActionBar = new WindowDecorActionBar(this); mActionBar.setDefaultDisplayHomeAsUpEnabled(mEnableDefaultActionBarUp); mWindow.setDefaultIcon(mActivityInfo.getIconResource()); mWindow.setDefaultLogo(mActivityInfo.getLogoResource());&#125; 返回ActionBar的引用前进行一次初始化，然后看到真正返回的是WindowDecorActionBar的实例，这个类继承了ActionBar并实现了它的所有方法。在new这个WindowDecorActionBar的时候传人了当前Activity的引用。再看看WindowDecorActionBar的构造方法里做了什么操作 123456789101112131415161718192021222324252627282930313233343536public WindowDecorActionBar(Activity activity) &#123; mActivity = activity; Window window = activity.getWindow(); View decor = window.getDecorView(); boolean overlayMode = mActivity.getWindow().hasFeature(Window.FEATURE_ACTION_BAR_OVERLAY); init(decor); if (!overlayMode) &#123; mContentView = decor.findViewById(android.R.id.content); &#125;&#125;private void init(View decor) &#123; mOverlayLayout = (ActionBarOverlayLayout) decor.findViewById( com.android.internal.R.id.decor_content_parent); if (mOverlayLayout != null) &#123; mOverlayLayout.setActionBarVisibilityCallback(this); &#125; mDecorToolbar = getDecorToolbar(decor.findViewById(com.android.internal.R.id.action_bar)); mContextView = (ActionBarContextView) decor.findViewById( com.android.internal.R.id.action_context_bar); mContainerView = (ActionBarContainer) decor.findViewById( com.android.internal.R.id.action_bar_container); mSplitView = (ActionBarContainer) decor.findViewById( com.android.internal.R.id.split_action_bar); if (mDecorToolbar == null || mContextView == null || mContainerView == null) &#123; throw new IllegalStateException(getClass().getSimpleName() + &quot; can only be used &quot; + &quot;with a compatible window decor layout&quot;); &#125; mContext = mDecorToolbar.getContext(); mContextDisplayMode = mDecorToolbar.isSplit() ? CONTEXT_DISPLAY_SPLIT : CONTEXT_DISPLAY_NORMAL; ...&#125; 在构造方法里也是做一些初始化的工作，主要是从docor view（window的root view）中find到和ActionBar有关的view并保存到成员变量，那后续就可以控制这些view了。 至此，窗口就为应用集成了ActionBar","raw":null,"content":null,"categories":[],"tags":[{"name":"ActionBar","slug":"ActionBar","permalink":"https://susyx.github.io/tags/ActionBar/"},{"name":"Android","slug":"Android","permalink":"https://susyx.github.io/tags/Android/"}]},{"title":"Android ActionBar计划","slug":"action-bar-plan","date":"2016-05-15T02:45:28.000Z","updated":"2016-05-25T02:10:06.000Z","comments":true,"path":"2016/05/15/action-bar-plan/","link":"","permalink":"https://susyx.github.io/2016/05/15/action-bar-plan/","excerpt":"开始写博客吧！ ActionBar学习计划前言对着ActionBar也有一段时间了，算是比较熟也能拿得出场子的东西，就以它作为开山之作吧。 想了解一下ActionBar的历史，猛的发现我们大神的博客有介绍ActionBar的使用，还十分详细，想了解用法的可以去看看：http://blog.csdn.net/xyz_lmn/article/details/8132420。 这里我就不废话ActionBar的前世今生了。虽然从Android 4.4开始，我就接触ActionBar，但我并不想再去详细说旧版本的东西，这是ActionBar的学习计划，我也本着学习的心态从较新的Android M版本出发来介绍ActionBar的实现。 由于ActionBar是一个比较庞大的组件，它并不是一个独立的View，是由许多View和控制辅助类来共同实现的，另外我是博客菜鸟，文章写的比较慢，如果要把一整套完成后才发布可能要等到猴年马月，所以打算是把它分成一系列的文章来学习，也算是一个循序渐进的过程，文章短短的也好接受（老罗的Android之旅尼玛有些文章长的我都没信心看了）。如果你看到这系列文章，我已经假定你已经把Android M的源码下载下来了。","keywords":null,"text":"开始写博客吧！ ActionBar学习计划前言对着ActionBar也有一段时间了，算是比较熟也能拿得出场子的东西，就以它作为开山之作吧。 想了解一下ActionBar的历史，猛的发现我们大神的博客有介绍ActionBar的使用，还十分详细，想了解用法的可以去看看：http://blog.csdn.net/xyz_lmn/article/details/8132420。 这里我就不废话ActionBar的前世今生了。虽然从Android 4.4开始，我就接触ActionBar，但我并不想再去详细说旧版本的东西，这是ActionBar的学习计划，我也本着学习的心态从较新的Android M版本出发来介绍ActionBar的实现。 由于ActionBar是一个比较庞大的组件，它并不是一个独立的View，是由许多View和控制辅助类来共同实现的，另外我是博客菜鸟，文章写的比较慢，如果要把一整套完成后才发布可能要等到猴年马月，所以打算是把它分成一系列的文章来学习，也算是一个循序渐进的过程，文章短短的也好接受（老罗的Android之旅尼玛有些文章长的我都没信心看了）。如果你看到这系列文章，我已经假定你已经把Android M的源码下载下来了。 计划大纲 ActionBar是Android UI的一个重要组成部分，是系统自动为应用窗口集成的。当应用使用了设备主题（DeviceDefault）、Material主题和Holo主题，系统就会加载用于实现ActionBar功能的View。然后应用通过ActionBar这个类提供的接口来控制显示或使用其功能。那么窗口集成的过程是怎样的，首先会对其进行剖析——Android中窗口添加ActionBar ActionBar是由众多View来共同实现的，那么每个View的作用和之间的关系是怎样的，会在第二篇文章来学习。 Toolbar，作为ActionBar最重要的功能实现View，以及Google非常推荐应用开发者放弃使用系统ActionBar而把Toolbar作为自己布局的一部分，然后调用setActionBar（或appcompat中的setSupportActionBar）方法来实现ActionBar的某些功能，它到底神奇在哪，第三篇文章来详细学习Toolbar的实现。 使用ActionBar，应该必不可少有option menu，ActionBar上的菜单也涉及非常多类。第四篇文章就来学习ActionBar如何加载和现实菜单。 option menu点击之后是如何回调到Activity中的onOptionMenuSelected方法的，第五篇文章来梳理菜单的点击响应流程。 这五篇文章完成后，对ActionBar应该都会有个感性并理性的认识，从此就不再觉得ActionBar有多神秘和厉害（当你对一样东西熟悉了就会觉得不过如是）。","raw":null,"content":null,"categories":[],"tags":[{"name":"ActionBar","slug":"ActionBar","permalink":"https://susyx.github.io/tags/ActionBar/"},{"name":"Android","slug":"Android","permalink":"https://susyx.github.io/tags/Android/"}]},{"title":"首篇","slug":"hello-world","date":"2016-04-24T07:36:52.000Z","updated":"2016-05-25T12:02:29.000Z","comments":true,"path":"2016/04/24/hello-world/","link":"","permalink":"https://susyx.github.io/2016/04/24/hello-world/","excerpt":"","keywords":null,"text":"博客终于，参考大神的这篇文章《史上最详细的Hexo博客搭建图文教程》搭建了自己的博客，现在都是hexo提供的模版，感觉hexo屌屌的，以后会抽时间在样式的定制上。 写博客主要是为了总结自己，以及培养自己写文档的能力（不写文档的程序员都不是好程序员），希望能多产出。 目标由于现在的工作重点是android控件，所以先把自己以前做过的工作——frameworks的部分控件整理一些文档出来，算是总结吧。 希望有了博客的推动，自己会在技术上多上心，然后可以多分享一些技术。","raw":null,"content":null,"categories":[],"tags":[{"name":"none","slug":"none","permalink":"https://susyx.github.io/tags/none/"}]}]}